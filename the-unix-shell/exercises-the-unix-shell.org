* Unix Shell Exercises

There is no way to learn shell (or git or python...) without using it. Here is some training. Comments:

- I will be adding more exercises to this file. I will split the file if it gets too crowded. But exercises numeration (A1, A2, B1...) will keep constant.

- Most exercises should not be time consuming - a few minutes at worst.

- Come at any time to ask me any questions. But remember, *--help*, *man*, *info*, your classmates and *google* might be faster (in that increasing speed order).

- My plan is to solve many exercises in class. Both as reinforcement and to introduce new concepts.

- At some point I might ask you to hand-in solutions for some exercises, using git. Nothing awful will happen if you don't, but I also need feedback.

- If I ask you to hand-in, *man script* might come handy.

- You do not need to be able to answer to all the questions now. Most probably, you will very soon.


** Run the initialization script
*** A1 Generate the exercises playground, create a command list

Run the following commands in an interactive shell. Let me know if something goes wrong.

#+begin_src bash

# Go to the exercises subdirectory in your carpentry directory
cd ~/carpentry/the-unix-shell/exercises

# Get the latest changes from the online repository
git pull

# Run the following command:
../scripts/initialize_exercises_dirtree.sh santi

# This should have generated some directories and files under the exercises directory.
# Creating many directories and files under:
#    /home/santi/Proyectos/imp/org/carpentry/--public/the-unix-shell/exercises/less

# Now go and explore your exercises playground directory
cd santi
ls -la

# I promise you there is some file with the string "secret" on these directories...
find . -iname '*secret*'
# ...did the last command help you to find it?

# You should be able to see a file called command-table.org
cat command-table.org | less
# That is a file that you can edit.
# Add very short descriptions and notes for the commands we have seen in class.
nano command-table.org
# Some of these commands we haven't seen.
# From now on you will be responsible to update the table with new commands.
# Although I will keep mine updated, so you can ask me for it at any time.

# You can notice that many files here have extension ".org"
# I just happen to like org-mode: http://orgmode.org/
# They are plain text files and you can read and edit them as you would any other text file
# If you do so with emacs or let github render them, they will look nice.
# See for example: https://github.com/strawlab/carpentry/blob/master/the-unix-shell/command-table.org
#+end_src

*** A2 Look into the initialisation script

As a general rule, one should always be aware and mildly trust whatever is being executed. Let's have a look at the script we have just run:
#+begin_src bash
less ../scripts/initialize_exercises_dirtree.sh
#+end_src

We haven't explicitly seen yet some concepts we need to fully understand the script: variables, conditionals, links... The script is very simple despite some (unnecessary) complexity added for the sake of making the script work no matter of the current working directory.

We will probably dissect this script in class. In the meantime, some questions for you to think:

**** What does it mean the "shebang", the initial two characters on the script?
#+begin_src bash
#!/bin/bash
#+end_src

**** How does the "-p" option change *mkdir* behavior?
As in:
#+begin_src bash
mkdir -p "${EXERCISES_DIR}"
#+end_src

What about the "--mode" option? What does it mean for a directory to have permissions "300"? This is probably something to ask in class...

**** How does the "-n" option change *cp* behavior?
As in:
#+begin_src bash
cp -n "$MY_DIR/../command-table.org" "${EXERCISES_DIR}"
#+end_src
- How does this relate to the redirection operator ">>".
- What does a programmer mean by "clobbering" a file?
- Why wouldn't I want to clobber your command-table.org file?

**** Why would one put curly brackets ("{}") around variable names.
As in:
#+begin_src bash
mkdir -p "${EXERCISES_DIR}/pdbs"
#+end_src

Was it needed here?

**** Why would one quote variable expansion when expanding paths?
For example:
#+begin_src bash
mkdir -p "${EXERCISES_DIR}"
#+end_src
Was it needed here?

**** What is the script purpose?

** Walking around the directory tree
The shell has associated a "working directory". The commands *pwd* and *cd* allow us to print and change the working directory. These are basic easy to use tools, but there are corner cases using them...

*** B1 Troubles changing directories
Change your working directory to your exercises "corner-cases" directory. For example:
#+begin_src bash
cd ~/carpentry/the-unix-shell/exercises/etienne/corner-cases
#+end_src

List the directory. Always using (the simplest) relative path from the "corner-cases" directory, try to change your directory to the following subdirectories:
#+begin_src bash
cd -dir-starting-with-dash
pwd
cd ~/carpentry/the-unix-shell/exercises/etienne/corner-cases

cd --dir-starting-with-doubledash and with spaces
pwd
cd ~/carpentry/the-unix-shell/exercises/etienne/corner-cases

cd -dir-starting-with-dash
pwd
cd ~/carpentry/the-unix-shell/exercises/etienne/corner-cases

#+end_src

Have any of these cd commands worked? Why? For the cases it haven't worked, make it work. Tips:

- How does cd interpret the dashes at the start of these directories names? There are a couple of ways of solving this...

- Once you know how to solve the "initial dash" problem, you might run into another problem and change to a directory different from the one you wanted to. What happened? How do you actually change to the directory we want to change to?

*** B2 Troubles with file permissions

# #+begin_src bash
# cd useless-dir
# pwd
# cd ~/carpentry/the-unix-shell/exercises/etienne/corner-cases
# #+end_src

*** B3 Hidden files
# There is a hidden directory in the corner-cases directory. List it and write down its name.

** Dissecting command line expansions

When the shell runs a command, it first *expands* the command line. Command line expansion transforms the command line by substituting several types of "expansions" (parts of the command line that are meant to be interpreted as something different than their literal translation) by its expanded value. For bash, a quite technically oriented explanation of all the possible expansions can be found in its [[http://www.gnu.org/software/bash/manual/bashref.html#Shell-Expansions][manual]] (which we can consult locally by running *man bash* or *info bash*). Expansion should also explained in detail in any book about the shell.

*** C1 Visualizing command lines expansion

Is there a way in which we could see what is the actual expansion that bash performs for us before calling our script? There is, and it is quite simple.

When executed, [[./scripts/show-command-line-expanded.sh*][the following script]] will print the command line as expanded by the parent shell.
#+begin_src bash
#!/bin/bash
echo "$0 $*"
#+end_src bash

How does this work? In a bash script bash provides us with [[http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameters][several useful variables]]. In this example we use two of them: *$0* represents the name of the program and *$** is the complete list of parameters, as expanded by the parent shell. Note that these are read only variables.

Let's use this script to visualize the different command line expansions from bash.

**** Is there any simpler alternative to the previous script?

Do we already know other command(s) that could help us to easily visualize the expanded command line?
We probably did not need to write our own script...


**** Practice brace expansion

What does the following expand to?
#+begin_src bash
cat {gal80,gal4,"Green Fluorescent Protein"}.txt
#+end_src bash

In which situation could such a command be useful? Contrast it to using filename expansion as in here:
#+begin_src bash
cat *.txt
#+end_src bash

See [[http://www.gnu.org/software/bash/manual/bashref.html#Brace-Expansion][brace expansion]] in the bash manual.


#**** Practice file name expansion

** Example project: Bash history tweaking

*** The truth about the bash history mechanism
*** ~/.bash_history
*** Optional: sourcing
*** When is the history read and written?
*** Tweaking bash: ~/.bashrc
*** Discussion: [[http://unix.stackexchange.com/questions/1288/preserve-bash-history-in-multiple-terminal-windows][Tweaking the history mechanism behavior]]

** Example project: Plotting molecules
*** PM1 Organize pdb files by their file contents
Goals: practice grep, pipes and symlinks
*** PM2 Downloading pdb files using wget and curl
Goals: practice xargs, backquoting
*** PM3 Extracting atom coordinates and plot them
Goals: practice grep with regular expressions

** Example project: Analyzing trajectories

** Example project: Managing fly stocks
** ProExercises

These are exercises that go beyond the basics...

*** P1 What is the current working directory of a GUI application?

Actually *any* program running in your system (process) has an associated working directory.

For example, execute libreoffice impress (or any other gui program you might have installed):
#+begin_src bash
loffice --help
loffice --impress
#+end_src

A new libreoffice process should run. What is its process id? There are many ways to find out, one of them is using pgrep.
#+begin_src bash
pgrep loffice
#+end_src

Now that we know the process id, there are also several ways of querying the system for its current working directory. One of them is the program *pwdx*. If you man for pwdx...

#+begin_src bash
man pwdx
----------------------------------------------
NAME
       pwdx - report current working directory of a process

SYNOPSIS
       pwdx [options] pid [...]
...
#+end_src

Write a command line that, given a program name (or more in general, a regular expression matching program names), shows its current working directory. My solution uses pgrep, pwdx and backquote expansion and can show more than one process at a time (given that pwdx accepts a list of process ids, as indicated in the SYNOPSIS by "[...]").

As a side note, sometimes the PWD of GUI applications correspond to what you see in "choose file dialogs". Is it the case for mozilla firefox?
